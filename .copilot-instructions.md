# WeihanLi.Common - Copilot Instructions

## Project Overview

WeihanLi.Common is a comprehensive .NET utility library providing common helpers, extensions, and utilities for .NET applications. The library includes dependency injection, AOP (Aspect-Oriented Programming), event handling, logging, data access extensions, TOTP implementation, template engine, and much more.

## Project Structure

```
├── src/                           # Main source code
│   ├── WeihanLi.Common/           # Core library
│   ├── WeihanLi.Common.Logging.Serilog/  # Serilog integration
│   └── WeihanLi.Extensions.Hosting/       # Hosting extensions
├── test/                          # Unit tests
│   └── WeihanLi.Common.Test/      # Test projects using xUnit
├── samples/                       # Sample applications
│   ├── AspNetCoreSample/          # ASP.NET Core examples
│   └── DotNetCoreSample/          # Console app examples
├── perf/                          # Performance benchmarks
├── docs/                          # Documentation using DocFX
├── build/                         # Build scripts and tools
└── .github/                       # CI/CD workflows
```

## Key Components

### Core Features
- **Dependency Injection**: Custom DI container similar to Microsoft's framework
- **Fluent Aspects (AOP)**: Dynamic proxy-based AOP framework
- **Event System**: EventBus, EventQueue, and EventStore implementations
- **Logging Framework**: Integration with Serilog and Microsoft logging
- **Data Extensions**: Dapper-like ADO.NET extensions for database operations
- **TOTP Implementation**: Time-based One-Time Password algorithm
- **Template Engine**: Custom template processing engine
- **HTTP Utilities**: HTTP client extensions and utilities
- **Guard Utilities**: Parameter validation helpers
- **Compression**: Data compression utilities
- **Extensions**: Extensive extension methods for common types

### Namespace Organization
- `WeihanLi.Common` - Core utilities and Guard classes
- `WeihanLi.Common.Aspect` - AOP framework components
- `WeihanLi.Common.Data` - Database and data access utilities
- `WeihanLi.Common.DependencyInjection` - DI container implementation
- `WeihanLi.Common.Event` - Event handling system
- `WeihanLi.Common.Extensions` - Extension methods for various types
- `WeihanLi.Common.Helpers` - Utility helper classes
- `WeihanLi.Common.Http` - HTTP-related utilities
- `WeihanLi.Common.Logging` - Logging abstractions and implementations
- `WeihanLi.Common.Otp` - TOTP and OTP implementations
- `WeihanLi.Common.Services` - Common service implementations
- `WeihanLi.Common.Template` - Template engine components

## Code Style and Conventions

### General Guidelines
- **Target Frameworks**: netstandard2.0, net8.0, net9.0, net10.0
- **Language Features**: C# with nullable reference types enabled, implicit usings
- **License**: Apache License 2.0
- **Naming**: PascalCase for public members, camelCase for private fields, following the editorconfig
- **Null Safety**: Extensive use of nullable annotations and Guard utilities

### Common Patterns

#### Guard Usage
Always validate parameters using the Guard class:
```csharp
public static string Process(string input)
{
    Guard.NotNullOrEmpty(input);
    // implementation
}
```

#### Extension Method Pattern
Extension methods should be in dedicated files with descriptive names:
```csharp
namespace WeihanLi.Extensions;

public static class StringExtension
{
    public static bool IsNullOrEmpty(this string? str) => string.IsNullOrEmpty(str);
}
```

#### Configuration Pattern
Use options pattern for configuration:
```csharp
public sealed class ServiceOptions
{
    public string ConnectionString { get; set; } = string.Empty;
    public int Timeout { get; set; } = 30;
}
```

#### Fluent API Design
Many components use fluent interfaces:
```csharp
FluentAspects.Configure(options =>
    options.InterceptAll()
           .With<LoggingInterceptor>()
);
```

## Testing Guidelines

### Test Structure
- Use xUnit as the testing framework
- Test files should be named `{ComponentName}Test.cs`
- Tests should be in the `WeihanLi.Common.Test` namespace
- Use descriptive test method names that explain the scenario

### Test Patterns
```csharp
[Fact]
public void MethodName_Scenario_ExpectedResult()
{
    // Arrange
    var input = "test";
    
    // Act
    var result = SystemUnderTest.Process(input);
    
    // Assert
    Assert.NotNull(result);
}

[Theory]
[InlineData("input1", "expected1")]
[InlineData("input2", "expected2")]
public void MethodName_MultipleInputs_ReturnsExpected(string input, string expected)
{
    var result = SystemUnderTest.Process(input);
    Assert.Equal(expected, result);
}
```

## Build and Development

### Build System
- Uses .NET 10 SDK
- Custom build scripts in `build/` directory using dotnet-execute
- Multi-targeting for compatibility across .NET versions
- Automated CI/CD with GitHub Actions and Azure DevOps

### .NET SDK Setup
The project requires .NET 10 SDK (with rollForward enabled to support newer versions). For development setup:

1. **Install .NET SDK**: Download and install .NET 10 SDK or later from [dotnet.microsoft.com](https://dotnet.microsoft.com/download)
2. **Multiple SDK Versions**: The GitHub Actions workflow (`.github/workflows/default.yml`) shows the supported SDK versions:
   ```yaml
   dotnet-version: |
     8.0.x
     9.0.x
     10.0.x
   ```
3. **Verify Installation**: Run `dotnet --info` to confirm the SDK is properly installed
4. **SDK Configuration**: The `global.json` file specifies the minimum SDK version with `rollForward: "latestMajor"` enabled

### Development Commands
```bash
# Build the solution
dotnet build

# Run tests
dotnet test

# Run custom build script
dotnet build.cs

# Format code
dotnet format
```

### Code Generation
Some files are generated using T4 templates (.tt files):
- Database extension methods
- Service container registration methods

## Common Tasks

### Adding New Extensions
1. Create extension class in appropriate `Extensions/` subdirectory
2. Use proper namespace (typically `WeihanLi.Extensions`)
3. Add comprehensive XML documentation
4. Write corresponding unit tests
5. Follow existing patterns for parameter validation

### Adding New Services
1. Define interface in `Abstractions/` if needed
2. Implement service in `Services/` directory
3. Add configuration options class if configurable
4. Register with DI container if applicable
5. Add integration tests

### Working with AOP
The Fluent Aspects framework allows method interception:
```csharp
// Configure interceptors
FluentAspects.Configure(options =>
{
    options.InterceptMethod<IService>(s => s.Process(Argument.Any<string>()))
           .With<ValidationInterceptor>();
});

// Create proxy
var service = FluentAspects.AspectOptions.ProxyFactory
    .CreateProxy<IService>(new ServiceImplementation());
```

### Database Operations
Use the data extensions for database operations:
```csharp
// Query data
var users = connection.Select<User>("SELECT * FROM Users WHERE Age > @age", new { age = 18 });

// Repository pattern
var repository = new Repository<User>(() => connectionFactory.GetConnection());
var user = repository.Fetch(u => u.Id == userId);
```

## Dependencies and Compatibility

### Key Dependencies
- Microsoft.Extensions.Configuration
- Microsoft.Extensions.Logging
- Newtonsoft.Json
- System.ComponentModel.Annotations (for .NET Standard 2.0)

### Compatibility Notes
- Supports .NET Standard 2.0 for broad compatibility
- Modern .NET versions (8.0+) for latest features
- Conditional compilation for framework-specific optimizations
- AOT compatibility for .NET 8.0+

## Documentation

- XML documentation is required for all public APIs
- Use DocFX for generating documentation website
- Examples should be provided in the `samples/` directory
- README files should be updated when adding major features

## Performance Considerations

- Use `Span<T>` and `Memory<T>` where appropriate for modern .NET versions
- Avoid allocations in hot paths
- Use object pooling for frequently allocated objects
- Benchmark performance-critical code in `perf/` directory

## Security Guidelines

- Input validation using Guard utilities
- Proper disposal of resources
- Secure random number generation for cryptographic operations
- Avoid hardcoded secrets or credentials

## Contributing Guidelines

When contributing to this repository:
1. Follow existing code style and patterns
2. Add comprehensive tests for new functionality
3. Update documentation and examples
4. Ensure compatibility across target frameworks
5. Use conventional commit messages
6. Consider performance implications
7. Validate with existing build and test processes